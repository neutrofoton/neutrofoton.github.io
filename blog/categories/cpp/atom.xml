<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cpp | neutrofoton]]></title>
  <link href="http://neutrofoton.github.io/blog/categories/cpp/atom.xml" rel="self"/>
  <link href="http://neutrofoton.github.io/"/>
  <updated>2017-11-10T00:18:18+08:00</updated>
  <id>http://neutrofoton.github.io/</id>
  <author>
    <name><![CDATA[neutro]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Create and Consume C++ Class DLL on Windows]]></title>
    <link href="http://neutrofoton.github.io/blog/2017/09/14/create-and-consume-c-plus-plus-class-dll-on-windows/"/>
    <updated>2017-09-14T14:04:05+08:00</updated>
    <id>http://neutrofoton.github.io/blog/2017/09/14/create-and-consume-c-plus-plus-class-dll-on-windows</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/logo/cpp.png"></p>

<p>while visiting clients of the company I work on, sometime I still found some applications especially desktop application build on unmanaged code (such as Delphi, Visual Basic 6, C++, etc). Even though at the time of this blog post, many application build on .NET (managed code) on Windows platform. There are various reasons why they do not migrate to managed code which has some advantages over unmanaged code (such as the application still run well with the version of OS they use, rewrite app will need extra cost, etc). This means unmanaged code application is not dead at all for LOB app, even though the percentage is much lower than the managed one.</p>

<p>Maybe this topic seems out of date topic in the .NET era, but at least this post as a note for my self in case I need it on the other day.</p>

<p>While developing an application, usually we want to share some of our code with other application. Dynamic Link Library (DLL) is Microsoft&rsquo;s implementation of the shared library concept in the Microsoft Windows. The term DLL in this post will refer to unmanaged code and only focus to the one build with Visual C++ compiler on Windows environment.</p>

<p>When we create a DLL, we also create a .lib file that contains information of exported class or functions. When we build an executable that calls the DLL, the linker uses the exported symbols in the .lib file to store this information for the loader. When the loader loads a DLL, the DLL is mapped into the memory space of the executable.</p>

<p>An executable file links to (or loads) a DLL in one of two ways, <em>implicit</em> or <em>explicit linking</em>. In this post will create simple sample both of them how C++ class exported in the two ways. The samples in this post created using IDE Microsoft Visual Studio 2013 Ultimate. To simplify the code, I just created a single solution contains a Win32 DLL project and a console application client. The DLL project contains classes for both sample <em>implicit</em> and <em>explicit linking</em>. Either the console application contains sample code for <em>implicit</em> and <em>explicit linking</em> caller. Here is the classes I use in this sample.</p>

<p><img class="center" src="/images/post/2017-09-04-classdiagram.png"></p>

<h2>Implicit Linking</h2>

<p><em>Implicit linking</em>, where the operating system loads the DLL when the executable using it is loaded. The executable client calls the exported functions of the DLL just as if the functions were statically linked and contained within the executable. <em>Implicit linking</em> is sometimes referred to as static load or load-time dynamic linking<sup>[4]</sup>. Now let&rsquo;s create a sample of DLL with <em>implicit linking</em>.</p>

<p>First of all, create an empty solution in Visual Studio by selecting <code>File</code> > <code>New Project</code> > scroll down on the left pane, expand <code>Other Project Types</code> > <code>Visual Studio Solutions</code> select <code>Black Solution</code>. Fill the solution name as <code>VCppDLL</code>.</p>

<p>Now we have an empty solution in Visual Studio. Right click the <code>VCppDLL</code> solution > <code>Add</code> > <code>New Project</code>. In the left pane of the New Project dialog box, expand Installed templates <code>Visual C++</code>, and then select <code>Win32</code>. Fill the project name as <strong>MathWin32DLL</strong>, then click OK.</p>

<p>On the Win32 Application Wizard dialog in the <code>Application Settings</code> part, select <code>DLL</code> and check <code>Empty project</code>, then click Finish</p>

<p><img class="center" src="/images/post/2017-09-04-Win32AppWizard.png"></p>

<p>Now we have an empty C++ DLL project in the Visual Studio solution. As the class diagram picture above, let create a simple <code>BaseMath</code> class. Right click the MathWin32DLL project > <code>Add</code> > <code>Class</code>. On <code>Visual C++</code> template on the left pane dialog, select <code>C++ Class</code> > click <code>Add</code>. On the <code>Generic C++ Class Wizard</code>, fill the <code>Class name</code> as <strong>BaseMath</strong> then click <code>Finish</code>. Edit the <code>BaseMath.h</code> with the following code.</p>

<pre><code class="cpp BaseMath.h">// If you are building the DLL project on the command line,
// use the /D compiler option to define the MATHDLLWIN32_EXPORTS symbol.

#pragma once

#ifdef MATHWIN32DLL_EXPORTS
#define Math_API __declspec(dllexport)
#else
#define Math_API __declspec(dllimport)
#endif // MATHWIN32DLL_EXPORTS

#include &lt;string&gt;

using namespace std;

namespace core
{
    class BaseMath
    {
    public:
        virtual void Destroy()
        {
            delete this;
        }

        virtual string Say(string&amp; s) = 0;
        virtual double Calculate(const double a, const double b) = 0;
    };
}
</code></pre>

<p>We can delete <code>BaseMath.cpp</code> file since we will make the <code>BaseMath</code> as an <em>abstract class</em>.</p>

<p>In Visual Studio, by default the New Project template for a DLL adds PROJECTNAME_EXPORTS to the defined preprocessor symbols for the DLL project. We can see the preprocessor symbols definition in <code>Property Pages</code> of <strong>MathWin32DLL</strong> project in the <code>Configuration Properties</code> > <code>C/C++</code> > <code>Preposesor</code> > <code>Preposesor Definitions</code>.</p>

<p><img class="center" src="/images/post/2017-09-04-preposesordefinitions.png"></p>

<p>In the code of <code>BaseMath.h</code>, when <code>MATHWIN32DLL_EXPORTS</code> symbol is defined, the <code>Math_API</code> symbol is set to <code>__declspec(dllexport)</code> modifier otherwise it is set to <code>__declspec(dllimport)</code>. The <code>__declspec(dllexport)</code> modifier can be applied to classes, functions, or variables that tells the compiler and linker to export them from the DLL so that it can be used by other applications.</p>

<p>Meanwhile when we include <code>BaseMath.h</code> in client project, <code>Math_API</code> is set to <code>__declspec(dllimport)</code>. This modifier optimizes the import of the exported class in an application.</p>

<p>For the next, let&rsquo;s create another class called <code>AddOperationMath</code>. Edit the <code>AddOperationMath.h</code> and <code>AddOperationMath.cpp</code> respectively as follow.</p>

<pre><code class="cpp AddOperationMath.h">#pragma once
#include "BaseMath.h"

using namespace std;

namespace core
{
  // MS Visual C++ compiler emits C4275 warning about not exported base class.
    class Math_API AddOperationMath : public BaseMath
    {
    public:
        AddOperationMath();
        virtual ~AddOperationMath();


        string Say(string&amp; s);
        double Calculate(const double a, const double b);

        static double Add(const double a, const double b);
    };
}
</code></pre>

<pre><code class="cpp AddOperationMath.cpp">
#include "AddOperationMath.h"

namespace core
{
    AddOperationMath::AddOperationMath()
    {
    }

    AddOperationMath::~AddOperationMath()
    {
    }

    string AddOperationMath::Say(string&amp; s)
    {
        string result =  s + " is calling add operation of class AddOperationMath";
        return result;
    }

    double AddOperationMath::Calculate(const double a, const double b)
    {
        return a + b;
    }

    double AddOperationMath::Add(const double a, const double b)
    {
        return a + b;
    }
}
</code></pre>

<p>The class <code>AddOperationMath</code> inherits from <code>BaseMath</code>. We also mark the <code>AddOperationMath</code> class with <code>Math_API</code> macro that&rsquo;s defined in <code>BaseMath.h</code> which means we will expose the <code>AddOperationMath</code> class in the DLL to executable client application. When we compile the DLL project, we should get a warning</p>

<pre><code class="text">warning C4275: non dll-interface class 'core::BaseMath' used as base for dll-interface class 'core::AddOperationMath'
</code></pre>

<p>In this case, ideally we should export (mark with <code>Math_API</code> macro) both <code>core::BaseMath</code> and <code>core::AddOperationMath</code> to make the compiler does not fire the warning message.</p>

<p>To complete our sample, let&rsquo;s create another project called <strong><em>MathWin32ClientConsole</em></strong> as we did the creation of <strong><em>MathWin32DLL</em></strong> project, except select <code>Console Application</code> instead of <code>DLL</code> in the <code>Application Settings</code> dialog.</p>

<p>In the <strong><em>MathWin32ClientConsole</em></strong> project, right click > <code>Add</code> > <code>New Item</code>. Select <code>Visual C++</code> project template on the left pane, then select <code>C++ File (.cpp)</code>. Fill the name with <code>Main.cpp</code>.</p>

<p>To make the <strong><em>MathWin32ClientConsole</em></strong> project has reference to <strong><em>MathWin32DLL</em></strong> project, right click <strong><em>MathWin32ClientConsole</em></strong> project > <code>Properties</code>. Scroll up the <code>Property Pages</code> dialog, expand <code>Common Properties</code> on the left pane > select <code>References</code>. Click <code>Add New Reference</code> button, select <code>Projects</code> and check the <code>MathWin32DLL</code> > <code>OK</code>. Now you should see <code>MathWin32DLL</code> added to the <code>References</code> pane as the following picture.</p>

<p> <img class="center" src="/images/post/2017-09-04-MathWin32ClientConsoleReference.png"></p>

<p> To make the <code>AddOperationMath</code> class is recognized in the <strong><em>MathWin32ClientConsole</em></strong> project, we have to include <code>AddOperationMath.h</code>. We can copy the <code>AddOperationMath.h</code> and <code>BaseMath.h</code> to the <strong><em>MathWin32ClientConsole</em></strong> project. But it is not a good way in our scenario, because if we make changes to one of them, we have to recopy it to the <strong><em>MathWin32ClientConsole</em></strong> project directory. To avoid this manual copy, we can include the <strong><em>MathWin32DLL</em></strong> project directory to the <strong><em>MathWin32ClientConsole</em></strong> so that we can include any header files of <strong><em>MathWin32DLL</em></strong> to <strong><em>MathWin32ClientConsole</em></strong> if needed. To do that open the Property pages of <strong><em>MathWin32ClientConsole</em></strong>, select <code>Configuration Properties</code> > <code>C/C++</code> > <code>General</code>. Select the drop-down control next to the <code>Additional Include Directories</code> edit box, and then choose <code>&lt;Edit...&gt;</code>. Select the top pane of the <code>Additional Include Directories</code> dialog box to enable an edit control. In the edit control, fill <code>$(SolutionDir)\MathWin32DLL</code> which tells to Visual Studio to scan or search header files that we include in directory <code>MathWin32DLL</code> inside solution directory.</p>

<p> <img class="center" src="/images/post/2017-09-04-IncludeMathWin32DLLDirectory.png"></p>

<p>Now we can include header file defined in <code>MathWin32DLL</code> from <code>MathWin32ClientConsole</code>. Let create code that call class defined in the DLL.</p>

<pre><code class="cpp Main.cpp">
#include &lt;iostream&gt;
#include &lt;string&gt;

#include "AddOperationMath.h"

using namespace std;


void CallDLLByImplicitLinking(double a, double b, string s);

int main()
{
    double a = 2;
    double b = 4;
    string s = "neutro";

    CallDLLByImplicitLinking(a, b, s);


    cout &lt;&lt; "Press any key to exit ";
    cin.get();

    return 0;
}



void CallDLLByImplicitLinking(double a, double b, string s)
{
    cout &lt;&lt; a &lt;&lt; " + " &lt;&lt; b &lt;&lt; " = " &lt;&lt; core::AddOperationMath::Add(a, b) &lt;&lt; endl;

    core::AddOperationMath* math = new core::AddOperationMath();
    cout &lt;&lt; math-&gt;Say(s) &lt;&lt; endl;

    delete math;

    cout &lt;&lt; endl &lt;&lt; "===============================================================" &lt;&lt; endl;
}
</code></pre>

<pre><code class="text Output">2 + 4 = 6
neutro is calling add operation of class AddOperationMath

Press any key to exit
</code></pre>

<blockquote><p>There is no need to explicitly specify a calling convention for exporting classes or their methods. By default, the C++ compiler uses the <code>__thiscall</code> calling convention for class methods. However, due to different naming decoration schemes that are used by different compilers, the exported C++ class can only be used by the same compiler and by the same version of the compiler. Only the MS Visual C++ compiler can use this DLL now. Both the DLL and the client code must be compiled with the same version of MS Visual C++ in order to ensure that the naming decoration scheme matches between the caller and the callee<sup>[5]</sup></p></blockquote>

<p>To use a DLL by <em>implicit linking</em>, an executable must include the header files that declare the data, functions or C++ classes exported by the DLL in each source file that contains calls to the exported data, functions, and classes.  The classes, functions, and data exported by the DLL must all be marked <code>__declspec(dllimport)</code> in the header file. From a coding perspective, calls to the exported functions are just like any other function call.</p>

<p>To build the calling executable file, we must link with the import library (.lib). If we use an external makefile or build system, we need to specify the file name of the import library where we list other object (.obj) files or libraries that we link.</p>

<p>The operating system must be able to locate the DLL file when it loads the calling executable. This means that we must deploy or verify the existence of the DLL when our application is installed.</p>

<h2>Explicit Linking</h2>

<p><em>Explicit linking</em>, where the operating system loads the DLL on demand at runtime. An executable that uses a DLL by <em>explicit linking</em> must make function calls to explicitly load and unload the DLL and to access the functions exported by the DLL. Unlike calls to functions in a statically linked library, the client executable must call the exported functions in a DLL through a function pointer. <em>Explicit linking</em> is sometimes referred to as dynamic load or run-time dynamic linking<sup>[4]</sup>.</p>

<p>To use a DLL by <em>explicit linking</em>, applications must make a function call to explicitly load the DLL at run time. To explicitly link to a DLL, an application must <sup>[4]</sup>:</p>

<ol>
<li><p>Call <code>LoadLibrary</code>, <code>LoadLibraryEx</code>, or a similar function to load the DLL and obtain a module handle.</p></li>
<li><p>Call <code>GetProcAddress</code> to obtain a function pointer to each exported function that the application calls. Because applications call the DLL functions through a pointer, the compiler does not generate external references, so there is no need to link with an import library. However, you must have a typedef or using statement that defines the call signature of the exported functions that you call.</p></li>
<li><p>Call <code>FreeLibrary</code> when done with the DLL.</p></li>
</ol>


<p>To create a sample for <em>explicit linking</em>, we will use an abstract interface (a class with pure virtual methods, and no data) and create a factory method for object instantiation.</p>

<p>On the <strong><em>MathWin32DLL</em></strong> create a new class called <code>LogarithmicMath</code>. Edit the header and implementation files as follow</p>

<pre><code class="cpp LogarithmicMath.h">
#pragma once

#include "BaseMath.h"

namespace core
{
    class LogarithmicMath : public BaseMath
    {
    public:
        LogarithmicMath();
        virtual ~LogarithmicMath();


        string Say(string&amp; s);
        double Calculate(const double a, const double b);
    };
}
</code></pre>

<pre><code class="cpp LogarithmicMath.cpp">#include "LogarithmicMath.h"
#include &lt;math.h&gt;

namespace core
{
    LogarithmicMath::LogarithmicMath()
    {
    }


    LogarithmicMath::~LogarithmicMath()
    {
    }

    string LogarithmicMath::Say(string&amp; s)
    {
        string result = s + " is calling Logarithmic operation of class LogarithmicMath";
        return result;
    }

    double LogarithmicMath::Calculate(const double a, const double b)
    {
        return log10(b) / log10(a);
    }
}
</code></pre>

<p>Next, create a <code>Factory</code> class that encapsulates <code>LogarithmicMath</code> instantiation and will be called from client app.</p>

<pre><code class="cpp Factory.h">#include "BaseMath.h"

using namespace std;

extern "C" Math_API core::BaseMath* __cdecl CreateLogarithmicMath();
</code></pre>

<pre><code class="cpp Factory.cpp">#include "Factory.h"
#include "LogarithmicMath.h"

using namespace std;

core::BaseMath* CreateLogarithmicMath()
{
    return new core::LogarithmicMath();
}
</code></pre>

<p>We can see that the <code>LogarithmicMath</code> class look like a standard C++ class. Instead of directly export the <code>LogarithmicMath</code> class, we use <code>Factory</code> that handle the export technics.</p>

<p>In the <code>Factory.h</code> defined <code>extern "C"</code> which tells the C++ compiler that the linker should use the C calling convention. It is required in order to prevent the mangling of the function name. So, this function is exposed as a regular C function, and can be easily recognized by any C-compatible compiler. The name itself is exported from the DLL unmangled (<code>CreateLogarithmicMath</code>). The <code>Math_API</code> tells the linker to export the <code>CreateLogarithmicMath</code> method from the DLL. <code>__cdecl</code> is the default calling convention for C and C++ programs.</p>

<p>Now let create a sample code in the <strong><em>MathWin32ClientConsole</em></strong> by editing the <code>Main.cpp</code> as following.</p>

<pre><code class="cpp Main.cpp">
#include &lt;iostream&gt;
#include &lt;string&gt;

#include &lt;Windows.h&gt;

#include "AddOperationMath.h"

using namespace std;

typedef core::BaseMath* (__cdecl *LogarithmicMathFactory)();

void CallDLLByImplicitLinking(double a, double b, string s);
void CallDLLByExplicitLinking(double a, double b, string s);

int main()
{
    double a = 2;
    double b = 4;
    string s = "neutro";

    CallDLLByImplicitLinking(a, b, s);
    CallDLLByExplicitLinking(a, b, s);


    cout &lt;&lt; "Press any key to exit ";
    cin.get();

    return 0;
}



void CallDLLByImplicitLinking(double a, double b, string s)
{
    cout &lt;&lt; a &lt;&lt; " + " &lt;&lt; b &lt;&lt; " = " &lt;&lt; core::AddOperationMath::Add(a, b) &lt;&lt; endl;

    core::AddOperationMath* math = new core::AddOperationMath();
    cout &lt;&lt; math-&gt;Say(s) &lt;&lt; endl;

    delete math;

    cout &lt;&lt; endl &lt;&lt; "===============================================================" &lt;&lt; endl;
}


void CallDLLByExplicitLinking(double a, double b, string s)
{
    HMODULE dll = LoadLibrary(L"MathWin32DLL.dll");
    if (!dll)
    {
        cout &lt;&lt; "Fail load library" &lt;&lt; endl;
        return;
    }

    LogarithmicMathFactory factory = reinterpret_cast&lt;LogarithmicMathFactory&gt;(GetProcAddress(dll, "CreateLogarithmicMath"));

    if (!factory)
    {
        cerr &lt;&lt; "Unable to load CreateLogarithmicMath from DLL!\n";
        FreeLibrary(dll);
        return;
    }

    core::BaseMath* instance = factory();
    cout &lt;&lt; a &lt;&lt; " log (" &lt;&lt; b &lt;&lt; ") = " &lt;&lt; instance-&gt;Calculate(a, b) &lt;&lt; endl;
    cout &lt;&lt; instance-&gt;Say(s) &lt;&lt; endl;

    instance-&gt;Destroy();

    FreeLibrary(dll);

    cout &lt;&lt; endl &lt;&lt; "===============================================================" &lt;&lt; endl;
}
</code></pre>

<p>Now build and run the <strong><em>MathWin32ClientConsole</em></strong>, we should get the following output.</p>

<pre><code class="text output">2 + 4 = 6
neutro is calling add operation of class AddOperationMath

===============================================================
2 log (4) = 2
neutro is calling Logarithmic operation of class LogarithmicMath

===============================================================
Press any key to exit
</code></pre>

<p>In order to ensure proper resource release, an abstract interface provides an additional method for the disposal of an instance. In this case we provide <code>Destroy</code> method. Calling this method manually can be tedious and error prone. It&rsquo;s recommend use smart pointer for auto resource release instead of manual release.</p>

<p>The code of this article can be found <a href="https://github.com/neutrofoton/VCppDLL">here</a></p>

<h2>References New</h2>

<ol>
<li><a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp">https://docs.microsoft.com/en-us/cpp/build/walkthrough-creating-and-using-a-dynamic-link-library-cpp</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/1ez7dh12.aspx">https://msdn.microsoft.com/en-us/library/1ez7dh12.aspx</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/build/dlls-in-visual-cpp">https://docs.microsoft.com/en-us/cpp/build/dlls-in-visual-cpp</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll#determining-which-linking-method-to-use">https://docs.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll#determining-which-linking-method-to-use</a></li>
<li><a href="https://www.codeproject.com/Articles/28969/HowTo-Export-C-classes-from-a-DLL">https://www.codeproject.com/Articles/28969/HowTo-Export-C-classes-from-a-DLL</a></li>
<li><a href="http://eli.thegreenplace.net/2011/09/16/exporting-c-classes-from-a-dll">http://eli.thegreenplace.net/2011/09/16/exporting-c-classes-from-a-dll</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Set With Custom Comparator]]></title>
    <link href="http://neutrofoton.github.io/blog/2016/12/30/c-plus-plus-set-with-custom-comparator/"/>
    <updated>2016-12-30T10:42:04+08:00</updated>
    <id>http://neutrofoton.github.io/blog/2016/12/30/c-plus-plus-set-with-custom-comparator</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/logo/cpp.png"></p>

<p><code>std::set</code> is a C++ STL container that store unique elements following a specific order. It is defined in the <code>set</code> header file.
<br/></p>

<p>Benefits and Features of <code>std::set</code>[3]:</p>

<p><ol>
<li>It’s doesn’t allow duplicate elements i.e. it only contains unique elements</li>
<li>
<code>std::set</code> can contain element of any specified type in template argument
</li>
<li>
<code>std::set</code> internally store elements in balanced binary tree
</li>
<li>
 By default <code>std::set</code> uses the operator <code> &lt; </code> for comparing two elements and but if user passes the external sorting criteria i.e. comparator then it uses it instead of default operator <code> &lt; </code>.
</li>
<li>
<code>std::set</code> will keep the inserted elements in sorted order based on the assigned sorting criteria i.e. either by default criteria operator <code> &lt; </code> or by passed comparator (if passed).
</li></p>

<p>In this post the samples only limited to <code>std::set</code> that use custom comparator and store complex object instead of basic data type. The complex object that we will use is reusing class <code>Person</code> on previous post.</p>

<p>Let&rsquo;s create custom class that handles comparation process</p>

<pre><code class="c++ CustomCompare">
#ifndef CustomCompare_h
#define CustomCompare_h

#include "Person.hpp"

struct CustomCompare
{
    bool operator()(const int&amp; lhs, const int&amp; rhs)
    {
        return lhs &lt; rhs;
    }

    bool operator()(const Person&amp; lhs, const Person&amp; rhs)
    {
        return lhs.getAge() &lt; rhs.getAge();
    }
};

#endif /* CustomCompare_h */
</code></pre>

<p>The following code is an example how to use the comparator class in <code>std:set</code>
<figure class='code'><figcaption><span>sample how to use</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">void</span> <span class="nf">SampleSetWithCustomCompare</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">set</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Person</span><span class="p">,</span><span class="n">CustomCompare</span><span class="o">&gt;</span> <span class="n">setOfPersons</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">setOfPersons</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="s">&quot;Person 1&quot;</span><span class="p">,</span> <span class="mi">25</span><span class="p">));</span>
</span><span class='line'><span class="n">setOfPersons</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="s">&quot;Person 2&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">));</span>
</span><span class='line'><span class="n">setOfPersons</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="s">&quot;Person 3&quot;</span><span class="p">,</span> <span class="mi">28</span><span class="p">));</span>
</span><span class='line'><span class="n">setOfPersons</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Person</span><span class="p">(</span><span class="s">&quot;Person 4&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="n">set</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">Person</span><span class="p">,</span><span class="n">CustomCompare</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">setOfPersons</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">setOfPersons</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">cout</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">it</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="s">&quot; , age : &quot;</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">it</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">getAge</span><span class="p">()</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h2>References</h2>

<ol>
<li><a href="http://www.cplusplus.com/reference/set/set/">http://www.cplusplus.com/reference/set/set/</a></li>
<li><a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-C-2nd-Edition.productCd-0470932449.html">http://www.wrox.com/WileyCDA/WroxTitle/Professional-C-2nd-Edition.productCd-0470932449.html</a></li>
<li><a href="http://thispointer.com/stdset-tutorial-part-1-set-usage-details-with-default-sorting-criteria/">http://thispointer.com/stdset-tutorial-part-1-set-usage-details-with-default-sorting-criteria/</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Priority Queue With Comparator]]></title>
    <link href="http://neutrofoton.github.io/blog/2016/12/29/c-plus-plus-priority-queue-with-comparator/"/>
    <updated>2016-12-29T15:52:23+08:00</updated>
    <id>http://neutrofoton.github.io/blog/2016/12/29/c-plus-plus-priority-queue-with-comparator</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/logo/cpp.png"></p>

<p><code>priority_queue</code> is categorized as a STL container adaptor. It is like a queue that keeps its element in sorted order. Instead of a strict FIFO ordering, the element at the head of the queue at any given time is the one with the highest priority.</p>

<p>The template class definition of <code>priority_queue</code> is as follow</p>

<pre><code class="c++ template definition">template &lt;
   class Type,
   class Container=vector&lt;Type&gt;,
   class Compare=less&lt;typename Container::value_type&gt; &gt;
class priority_queue
</code></pre>

<p>A user-provided compare can be supplied to change the ordering, e.g. using <code>std::greater<T></code> would cause the smallest element to appear as the top(). We also can create custom comparator for our need.</p>

<p>Many samples available on net about <code>priority_queue</code> with default compare parameter. In this article let&rsquo;s create samples by specifying the compare parameter template.</p>

<pre><code class="c++ priority_queue with std::greater">
//helper function displays sorted data
template&lt;class T&gt;
void printQueue(T&amp; q)
{
    while (!q.empty())
    {
        cout &lt;&lt; q.top() &lt;&lt; endl;
        q.pop();
    }
}

void SamplePriorityQueue()
{
    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; q;

    for(int n : {1,8,5,6,3,4,0,9,7,2})
        q.push(n);

    printQueue(q);
}
</code></pre>

<p>The code above uses <code>std::greater</code> as a compare parameter template.</p>

<pre><code class="bash output">0
1
2
3
4
5
6
7
8
9
</code></pre>

<p>Beside the <code>std::less</code> or <code>std::greater</code>, we can create our custom comparator with lamda or custom class or struct.</p>

<pre><code class="c++ lamda as compare parameter">
void SamplePriorityQueueWithLamda()
{
    // using lambda to compare elements.
    auto compare = [](int lhs, int rhs)
                {
                    return lhs &lt; rhs;
                };

    std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(compare)&gt; q(compare);

    for(int n : {1,8,5,6,3,4,0,9,7,2})
        q.push(n);


    printQueue(q);
}
</code></pre>

<p>To use the custom comparator, we just need to pass it as the third parameter of <code>priority_queue</code> template</p>

<pre><code class="c++ custom comparator">
struct CustomCompare
{
    bool operator()(const int&amp; lhs, const int&amp; rhs)
    {
        return lhs &lt; rhs;
    }
};
</code></pre>

<pre><code class="c++ sample with custom comparator">void SamplePriorityQueueWithCustomComparator()
{
    priority_queue&lt;int,vector&lt;int&gt;, CustomCompare &gt; pq;

    pq.push(3);
    pq.push(5);
    pq.push(1);
    pq.push(8);

    printQueue(pq);
}
</code></pre>

<p>The data stored in <code>priority_queue</code> is not limited to basic data type.
We can store object in it. Let&rsquo;s create a sample of it.
Let&rsquo;s say we have a <code>Person</code> class.</p>

<pre><code class="c++ Person.hpp">
#ifndef Person_hpp
#define Person_hpp

#include &lt;stdio.h&gt;
#include &lt;string&gt;

using namespace std;

class Person
{
public:
    Person();
    Person(string name, int age);
    virtual ~Person();

    string getName() const;
    int getAge() const;

    friend bool operator &lt; (const Person&amp; lhs, const Person&amp; rhs);
    friend bool operator &gt; (const Person&amp; lhs, const Person&amp; rhs);

private:
    string name;
    int age;
};

#endif /* Person_hpp */
</code></pre>

<pre><code class="c++ Person.cpp">#include "Person.hpp"

bool operator &lt; (const Person&amp; lhs, const Person&amp; rhs)
{
    return lhs.getAge() &lt; rhs.getAge();
}

bool operator &gt; (const Person&amp; lhs, const Person&amp; rhs)
{
    return lhs.getAge() &gt; rhs.getAge();
}

Person::Person()
{
}

Person::Person(string name, int age):name(name), age(age)
{
}

Person::~Person()
{   
}

string Person::getName() const
{
    return name;
}

int Person::getAge() const
{
    return age;
}
</code></pre>

<p>On the <code>Person</code> class, we have friend overloading methods, right angle bracket and left angle bracket. The methods act as comparation operator. The operator overloading is needed if we want to use <code>std::less</code> or <code>std::greater</code>.</p>

<pre><code class="c++ sample priority_queue stores object">
void SamplePriorityQueueStoreObject()
{
    vector&lt;Person&gt; personVector =
    {
        Person("Person 1", 25),
        Person("Person 2", 17),
        Person("Person 3", 35),
        Person("Person 4", 7),
        Person("Person 5", 50)
    };

    cout &lt;&lt; "======== Less Priority Queue ======= " &lt;&lt; endl;

    priority_queue&lt;Person, vector&lt;Person&gt;, less&lt;vector&lt;Person&gt;::value_type&gt;&gt; pqueue_less;

    //fill pqueue_less
    for (auto it = personVector.cbegin(); it!=personVector.cend(); it++)
    {
        pqueue_less.push(*it);
    }

    //iterate,display and pop
    while (!pqueue_less.empty())
    {
        Person value = pqueue_less.top();
        cout &lt;&lt; value.getName() &lt;&lt; " : " &lt;&lt; value.getAge() &lt;&lt; endl;

        pqueue_less.pop();
    }


    cout &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; "======== Greater Priority Queue ======= " &lt;&lt; endl;

    priority_queue&lt;Person, vector&lt;Person&gt;, greater&lt;vector&lt;Person&gt;::value_type&gt;&gt; pqueue_greater;
    //fill pqueue_greater
    for (auto it = personVector.cbegin(); it!=personVector.cend(); it++)
    {
        pqueue_greater.push(*it);
    }

    //iterate,display and pop
    while (!pqueue_greater.empty())
    {
        Person value = pqueue_greater.top();
        cout &lt;&lt; value.getName() &lt;&lt; " : " &lt;&lt; value.getAge() &lt;&lt; endl;

        pqueue_greater.pop();
    }
}
</code></pre>

<h2>References</h2>

<ol>
<li><a href="http://en.cppreference.com/w/cpp/container/priority_queue">http://en.cppreference.com/w/cpp/container/priority_queue</a></li>
<li><a href="https://support.microsoft.com/en-us/kb/837697">https://support.microsoft.com/en-us/kb/837697</a></li>
<li><a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-C-2nd-Edition.productCd-0470932449.html">http://www.wrox.com/WileyCDA/WroxTitle/Professional-C-2nd-Edition.productCd-0470932449.html</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lambda in C++]]></title>
    <link href="http://neutrofoton.github.io/blog/2016/05/12/lambda-in-c-plus-plus/"/>
    <updated>2016-05-12T00:15:18+08:00</updated>
    <id>http://neutrofoton.github.io/blog/2016/05/12/lambda-in-c-plus-plus</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/logo/lambda.png">
C++11 adds a new feature called lambda expressions. This allows us to write anonymous functions inline, removing the need to write a separate function or to write a function object, and makes code easier to understand.
For those who are familiar with C# lambda expression, C++ lambda expression is similar. But lambda in C++ has slightly different syntax.</p>

<pre><code class="text C++11 Lambda Syntax">[capture_block](parameters) mutable exception_specification -&gt; return_type {body}
</code></pre>

<ol>
<li> <strong><code>capture_block</code></strong> is a comma-separated list of zero or more captures, optionally beginning with a capture-default. Capture list can be passed as follows (see below for the detailed description):
<ol>
<li><code>[a,&b]</code> where a is captured by value and b is captured by reference.</li>
<li><code>[this]</code> captures the this pointer by value</li>
<li><code>[&]</code> captures all automatic variables odr-used in the body of the lambda by reference</li>
<li><code>[=]</code> captures all automatic variables odr-used in the body of the lambda by value</li>
<li><code>[x]</code> captures only x by value and nothing else.</li>
<li><code>[]</code> captures nothing</li>
</ol>
</li>
<li>
<strong><code>parameters</code></strong> is (optional) list of parameters for the lambda expression.
</li>
<li>
<strong><code>mutable</code></strong> is (optional) if variables from the enclosing scope are captured by value, a copy of those variables will become available in the body of the lambda expression. Those copies are marked as const by default, meaning the lambda body cannot change the value of those copies. If the lambda expression is marked as mutable, those copies are not const and the body can modify those local copies.
</li>
<li>
<strong><code>exception_specification</code></strong> is (optional) and can be used to specify which exceptions the body of the lambda expression can throw.
</li>
<li>
<strong><code>return_type</code></strong> is Return type. If not present it's implied by the function return statements (or void if it doesn't return any value)
</li>
</ol>




<h3>Lambda and Direct Invoke</h3>


<p>The following snipped code is an example of lambda expression.</p>

<pre><code class="cpp example lambda and directly invoked">
string result = [](const string&amp; str) -&gt; string {return "Hi " + str;}("neutro");
cout &lt;&lt; result &lt;&lt; endl;
</code></pre>

<p>The lambda expression above shows that it has a <code>const string&amp;</code> parameter and return a <code>string</code> type. To execute the lambda is by placing round brackets <code>()</code> and put object that will be passed to inside it. The <code>&ldquo;neutro&rdquo;</code> literal string will substitute <code>str</code> parameter. The output of the above code is :</p>

<pre><code class="text output">Hi neutro
</code></pre>

<h3>Lambda as Variable</h3>


<p>Pointer to a lambda expression can be stored and executed through the function pointer. C++ provides <code>std::function</code> which is a STL template class that provides a very convenient wrapper to a simple function, to a functor or to a lambda expression. We can also use the C++11 <code>auto</code> keyword to make it easier.</p>

<p>To make it clear the following code contains couples of various lambda expressions and store them in variables of type <code>auto</code> or its equivalent in <code>std::function</code> STL template class.</p>

<pre><code class="cpp lambda as variable">    auto lambda1 = [] { cout &lt;&lt;"Hello lambda without parameter 1" &lt;&lt; endl; };
    lambda1();

    auto lambda2 = [](void) { cout &lt;&lt;"Hello lambda without parameter 2" &lt;&lt; endl; };
    lambda2();

    //auto lambda3 = [](void) -&gt; void { cout &lt;&lt;"Hello lambda without parameter 2" &lt;&lt; endl; };
    function&lt;void()&gt; lambda3 = [](void) -&gt; void { cout &lt;&lt;"Hello lambda without parameter 2" &lt;&lt; endl; };
    lambda3();

    //auto lambda4 = [](const string&amp; str) -&gt; string {return "Hello from " + str;};
    function&lt;string(const string&amp;)&gt; lambda4 = [](const string&amp; str) -&gt; string {return "Hello from " + str;};

    string result = lambda4("neutro");

    cout &lt;&lt; result &lt;&lt; endl;
</code></pre>

<p>The snipped code above shows how lambda expressions stored in variable of auto type or theirs equivalent in <code>std::function</code> type and how to invoke the lambda. <a href="https://oopscenities.net/2012/02/24/c11-stdfunction-and-stdbind/">Here</a> is a good article about <code>std::function</code>.</p>

<h3>Lambda Capture Block</h3>


<p>Lambda Capture Block basically describes how we want to capture variables from the enclosing scope. Capturing a variable means that the variable becomes available inside the body of the lambda. The detail variant of capture block has been described on previous section. The following code shows various scenario how to play with capture block.</p>

<pre><code class="cpp lambda capture block">int variableA = 1;
int variableB = 1;
int variableC = 1;

cout &lt;&lt; "Init Values : "&lt;&lt;endl;
cout &lt;&lt; "variableA : "&lt;&lt;variableA &lt;&lt;endl;
cout &lt;&lt; "variableB : "&lt;&lt;variableB &lt;&lt;endl;
cout &lt;&lt; "variableC : "&lt;&lt;variableC &lt;&lt;endl;

cout &lt;&lt; endl;
//--------------------------------------
cout &lt;&lt; "---## lamda 1 ##---"&lt;&lt;endl;
auto lambda1 = [=](int param)-&gt; int     //==&gt; [=] lambda has default access to variable is by value
            {
                param = param * 2;

                cout &lt;&lt; "param inside lambda1 : "&lt;&lt;param &lt;&lt; endl;
                return param;
            };

lambda1(variableA);
cout &lt;&lt; "After lamda1, variableA : " &lt;&lt;variableA &lt;&lt;endl;

cout&lt;&lt;endl;

//--------------------------------------------
cout &lt;&lt; "---## lamda 2 ##---"&lt;&lt;endl;
auto lambda2 = [&amp;](int param) -&gt; int      //==&gt; [&amp;] lambda has default access to variable is by reference
            {
                param = param * 2;
                variableB = variableB * 2;

                cout &lt;&lt; "param inside lambda2 : "&lt;&lt;param &lt;&lt; endl;
                cout &lt;&lt; "variableB inside lambda2 : "&lt;&lt;variableB &lt;&lt; endl;

                return param;
            };

lambda2(variableA);
cout &lt;&lt; "After lamda2, variableA : " &lt;&lt;variableA &lt;&lt;endl;
cout &lt;&lt; "After lamda2, variableB : " &lt;&lt;variableB &lt;&lt;endl;

cout&lt;&lt;endl;

//-------------------------------------
cout &lt;&lt; "---## lamda 3 ##---"&lt;&lt;endl;
auto lambda3 = [&amp;](int* param) -&gt; int
{
    *param = (*param) * 2;
    variableB = variableB * 2;

    cout &lt;&lt; "param inside lambda3 : "&lt;&lt;*param &lt;&lt; endl;
    cout &lt;&lt; "variableB inside lambda3 : "&lt;&lt;variableB &lt;&lt; endl;

    return *param;
};

int result3 = lambda3(&amp;variableA);
cout &lt;&lt; "After lamda3, result3 : " &lt;&lt;result3 &lt;&lt;endl;
cout &lt;&lt; "After lamda3, variableA : " &lt;&lt;variableA &lt;&lt;endl;
cout &lt;&lt; "After lamda3, variableB : " &lt;&lt;variableB &lt;&lt;endl;

cout&lt;&lt;endl;


//--------------------------------
cout &lt;&lt; "---## lamda 4 ##---"&lt;&lt;endl;
auto lambda4 = [=, &amp;variableB, &amp;variableC](int param) -&gt; int //==&gt; [=, &amp;variableB, &amp;variableC] captures by value by default,
                                             // except variables variableB and variableC, which are captured by reference.
{
    param = (param) * 2;
    variableB = variableB * 2;
    variableC = variableC * 2;

    cout &lt;&lt; "param inside lambda4 : "&lt;&lt;param &lt;&lt; endl;
    cout &lt;&lt; "variableB inside lambda4 : "&lt;&lt;variableB &lt;&lt; endl;
    cout &lt;&lt; "variableC inside lambda4 : "&lt;&lt;variableC &lt;&lt; endl;

    return param;
};

lambda4(variableA);

cout &lt;&lt; "After lamda4, variableA : " &lt;&lt;variableA &lt;&lt;endl;
cout &lt;&lt; "After lamda4, variableB : " &lt;&lt;variableB &lt;&lt;endl;
cout &lt;&lt; "After lamda4, variableC : " &lt;&lt;variableC &lt;&lt;endl;

cout &lt;&lt; endl;

//--------------------------------
cout &lt;&lt; "---## lamda 5 ##---"&lt;&lt;endl;
auto lambda5 = [variableC](int param) mutable -&gt; int //==&gt; [variableC] captures only variableC by value and nothing else.
{
    param = (param) * 2;

    variableC = variableC * 2; //should mark as mutable lambda, since Cannot assign to a variable captured by copy in a non-mutable lambda
    //variableB = variableB * 2; //ERROR : variableB not captured, since only capture specific variable that's variableC

    ///
    cout &lt;&lt; "param inside lambda5 : "&lt;&lt;param &lt;&lt; endl;
    cout &lt;&lt; "variableC inside lambda5 : "&lt;&lt;variableC &lt;&lt; endl;

    return param;
};

lambda5(variableA);

cout &lt;&lt; "After lamda5, variableA : " &lt;&lt;variableA &lt;&lt;endl;
cout &lt;&lt; "After lamda5, variableC : " &lt;&lt;variableC &lt;&lt;endl;
</code></pre>

<p>The output of the sample code is :</p>

<pre><code class="text output">Init Values :
variableA : 1
variableB : 1
variableC : 1

---## lamda 1 ##---
param inside lambda1 : 2
After lamda1, variableA : 1

---## lamda 2 ##---
param inside lambda2 : 2
variableB inside lambda2 : 2
After lamda2, variableA : 1
After lamda2, variableB : 2

---## lamda 3 ##---
param inside lambda3 : 2
variableB inside lambda3 : 4
After lamda3, result3 : 2
After lamda3, variableA : 2
After lamda3, variableB : 4

---## lamda 4 ##---
param inside lambda4 : 4
variableB inside lambda4 : 8
variableC inside lambda4 : 2
After lamda4, variableA : 2
After lamda4, variableB : 8
After lamda4, variableC : 2

---## lamda 5 ##---
param inside lambda5 : 4
variableC inside lambda5 : 4
After lamda5, variableA : 2
After lamda5, variableC : 2
</code></pre>

<p><h4>Reference<h4>
<ol type="1">
<li><a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-C-2nd-Edition.productCd-0470932449.html">Wrox Professional C++</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/lambda">http://en.cppreference.com/w/cpp/language/lambda</a></li>
<li><a href="https://oopscenities.net/2012/02/24/c11-stdfunction-and-stdbind/">https://oopscenities.net/2012/02/24/c11-stdfunction-and-stdbind/</a></li>
<li><a href="http://www.drdobbs.com/cpp/lambdas-in-c11/240168241?pgno=1">http://www.drdobbs.com/cpp/lambdas-in-c11/240168241?pgno=1</a></li>
</ol></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configure Boost (C++ Libraries) on Xcode, Code::Blocks and Visual Studio]]></title>
    <link href="http://neutrofoton.github.io/blog/2016/03/27/configure-boost-c-plus-plus-on-xcode/"/>
    <updated>2016-03-27T21:38:49+08:00</updated>
    <id>http://neutrofoton.github.io/blog/2016/03/27/configure-boost-c-plus-plus-on-xcode</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/post/2016-03-27-boost.png">
<a href="http://www.boost.org/">Boost</a> is a set of libraries for the C++ programming language that provide support for tasks and structures such as linear algebra, pseudorandom number generation, multithreading, image processing, regular expressions, and unit testing. It contains over eighty individual libraries.<a href="https://en.wikipedia.org/wiki/Boost_(C%2B%2B_libraries)">[2]</a></p>

<p>The other interesting points of <a href="http://www.boost.org/">Boost</a> are :</p>

<ol>
<li>Open source</li>
<li>Cross platform</li>
<li>Complement to STL rather than a replacement</li>
<li>Many of <a href="http://www.boost.org/">Boost</a> developers are on the C++ standard committee</li>
<li>Well documented</li>
<li>Most of the Boost libraries are licensed under the <a href="https://en.wikipedia.org/wiki/Boost_(C%2B%2B_libraries)#License">Boost Software License</a>, designed to allow <a href="http://www.boost.org/">Boost</a> to be used with both free and proprietary software projects</li>
</ol>




<h2>Installation Boost</h2>


<p>Before jumping into steps of configuring <a href="http://www.boost.org/">Boost</a> on various IDE, let&rsquo;s begin with <a href="http://www.boost.org/">Boost</a> installation. To be noted that on this post I run Xcode on OS X, <a href="http://www.codeblocks.org/">Code::Blocks</a>  on Linux (Ubuntu) and Visual Studio on Windows. The detail environments I use are :</p>

<ol>
<li>OS X 10.11.4 El Capitan</li>
<li>Ubuntu 14.04.4 LTS</li>
<li>Xcode Version 7.2</li>
<li>Code::Blocks 13.12, gcc 4.8.4</li>
<li>Visual Studio 2013</li>
<li>Boost 1.60.0</li>
</ol>




<h4>OS X and Linux (Ubuntu)</h4>


<p>There are several ways of <a href="http://www.boost.org/">Boost</a> installation. Instead of build from source code, we can use package manager such as <a href="https://www.macports.org/">MacPorts</a>, <a href="http://brew.sh/">Homebrew</a>, <a href="https://en.wikipedia.org/wiki/Advanced_Packaging_Tool">Advance Package Tool</a>, etc. In this post we will build <a href="http://www.boost.org/">Boost</a> from source code. The installation steps (from source code) on OS X and Ubuntu are the similar. To make it consistent, I use the same installation path for OS X and Ubuntu that is <code>/usr/local/boost_1_60_0</code>. You can use different path if you want. The steps are :</p>

<ol>
<li>Download boost library from <a href="boost.org">Boost website</a></li>
<li>Extract it.</li>
<li>Open terminal, navigate to the extracted directory</li>
<li>Create directory on <code>/usr/local/boost_1_60_0</code>, and ensure IDE has access to the directory. On my case I don't need this step on OS X, but on ubuntu it does.
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo mkdir /usr/local/boost_1_60_0
</span><span class='line'>sudo chmod <span class="m">777</span> -r boost_1_60_0
</span></code></pre></td></tr></table></div></figure>
</li>
<li>
Run command :
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>./bootstrap.sh --prefix<span class="o">=</span>/usr/local/boost_1_60_0
</span><span class='line'>./b2 install
</span></code></pre></td></tr></table></div></figure>
This last step quite take time. So you can have coffee while waiting for it :)
</li>
</ol>


<p>Once the installation finish, we should have generated directory. They are <code>/usr/local/boost_1_60_0/include</code> contains header files and <code>/usr/local/boost_1_60_0/lib</code> contains libraries.</p>

<h4>Windows</h4>


<p>The <a href="http://www.boost.org/">Boost</a> installation step on Windows is also similar to the installation step on OS X and Ubuntu.
The steps are :</p>

<ol>
<li>Download boost library from <a href="boost.org">Boost website</a></li>
<li>Extract it to C:\\boost_1_60_0 </li>
<li>Open Visual Studio command prompt. I use Visual Studio 2013 x86 Native Tools Command Prompt native tool (I have not test using default Windows Command Prompt)
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bat'><span class='line'>C:\<span class="p">&gt;</span> <span class="n">cd</span> C:\boost_<span class="m">1</span>_<span class="m">60</span>_<span class="m">0</span>
</span><span class='line'>C:\boost_<span class="m">1</span>_<span class="m">60</span>_<span class="m">0</span><span class="p">&gt;</span> <span class="n">bootstrap</span>.bat
</span><span class='line'>C:\boost_<span class="m">1</span>_<span class="m">60</span>_<span class="m">0</span>&gt; .\b<span class="m">2</span>
</span></code></pre></td></tr></table></div></figure>
As on OS X and Ubuntu, the last step quite take time.
</li>
</ol>




<h2>Configure <a href="http://www.boost.org/">Boost</a> on IDE(s)</h2>


<p>Before create C++ projects on various IDE, let&rsquo;s create a simple C++ hello world code that use Boost libraries. To simplify the test, I grab sample code from <a href="http://stackoverflow.com/questions/999120/c-hello-world-boost-tee-example-program">here</a> <br/>
<figure class='code'><figcaption><span>Hello World</p></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">iostream</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">fstream</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">boost</span><span class="o">/</span><span class="n">iostreams</span><span class="o">/</span><span class="n">tee</span><span class="p">.</span><span class="n">hpp</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">boost</span><span class="o">/</span><span class="n">iostreams</span><span class="o">/</span><span class="n">stream</span><span class="p">.</span><span class="n">hpp</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">iostreams</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">typedef</span> <span class="n">tee_device</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">ostream</span><span class="p">,</span> <span class="n">ofstream</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">TeeDevice</span><span class="p">;</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">stream</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">TeeDevice</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">TeeStream</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">ofstream</span> <span class="nf">ofs</span><span class="p">(</span><span class="s">&quot;/Users/neutro/Workspace/cpp/sample.txt&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">TeeDevice</span> <span class="nf">my_tee</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
</span><span class='line'><span class="n">TeeStream</span> <span class="nf">my_split</span><span class="p">(</span><span class="n">my_tee</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">my_split</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="s">&quot;Hello, World!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">my_split</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
</span><span class='line'><span class="n">my_split</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
The snipped code above just print text and write it to a text file. We just want to ensure the IDE&rsquo;s compiler can compile and build the code that includes <a href="http://www.boost.org/">Boost</a> libraries.</p>

<ul>
  <li>
    <h4>Xcode</h4>
    To include Boost libraries on Xcode project :
    <ol>
    <li>Select Xcode project > Build Setting</li>
    <li>Add <code>/usr/local/boost_1_60_0/include/</code> to the Header Search Paths</li>
    <li>Add <code>/usr/local/boost_1_60_0/lib/</code> to the Library Search Paths</li>
    </ol>

    <img class="center" src="/images/post/2016-03-27-xcode.png">

  </li>
  <li>
    <h4>Code::Blocks</h4>
    To include Boost libraries on Code::Blocks project :
    <ol>
    <li>Right Click on Code::Blocks project > Build Option</li>
    <li>
    Select Compiler tab, add <code>/usr/local/boost_1_60_0/include/</code>
    <img class="center" src="/images/post/2016-03-27-codeblocks1.png">
    </li>
    <li>
    Select Linker tab, add <code>/usr/local/boost_1_60_0/lib/</code>
    <img class="center" src="/images/post/2016-03-27-codeblocks2.png">
    </li>
    </ol>
  </li>
  <li>
    <h4>Visual Studio</h4>
    To include Boost libraries on Visual C++ project :
    <ol>
    <li>Right Click on VC++ project > Properties</li>
    <li>Select VC++ Directories on the left pane</li>
    <li>Add <code>C:\boost_1_60_0</code> on Include Directories item</li>
    <li>Add <code>C:\boost_1_60_0\stage\lib</code> on Include Directories item</li>
    <li>Click OK to close the dialog</li>
    </ol>
    <img class="center" src="/images/post/2016-03-27-vs.png">
  </li>
</ul>


<p>The last is rebuild the above code on selected IDE. We should not got any errors once the IDE can detect the <a href="http://www.boost.org/">Boost</a> directory path.</p>

<p>The sample of this article can be downloaded <a href="https://github.com/neutrofoton/SimpleBoost">here</a></p>

<p><h4>Reference<h4>
<ol type="1">
<li>
<a href="http://www.boost.org/">http://www.boost.org/</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Boost_(C%2B%2B_libraries)">Wikipedia</a>
</li>
</ol></p>
]]></content>
  </entry>
  
</feed>
